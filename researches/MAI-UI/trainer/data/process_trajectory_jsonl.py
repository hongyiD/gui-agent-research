#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Process trajectory.jsonl to SFT training dataset.

This script converts trajectory.jsonl files (generated by GUI agent data collection)
into SFT-compatible training data format.

Input format (trajectory.jsonl):
{"step_index": 1, "thinking": "...", "action": {...}, "action_type": "click", ...}

Output format (OpenAI-compatible messages):
{
  "messages": [
    {"role": "system", "content": [...]},
    {"role": "user", "content": [{"type": "image_url", ...}, {"type": "text", ...}]},
    {"role": "assistant", "content": [{"type": "text", ...}]}
  ]
}

Usage:
    python process_trajectory_jsonl.py --input dataset/20260119_201327/trajectory.jsonl \
                                       --output data/sft_train.jsonl
"""

from __future__ import annotations

import argparse
import base64
import json
import os
from collections.abc import Generator
from io import BytesIO
from pathlib import Path
from typing import Any

import yaml # type: ignore
from PIL import Image # type: ignore    
from tqdm import tqdm # type: ignore


# System prompt for GUI agent
GUI_AGENT_SYSTEM_PROMPT = """You are a GUI agent. You are given a task and your action history, with screenshots. You need to perform the next action to complete the task.

## Output Format
For each action, return your thinking process and the action in the following format:

Thought: [Your analysis of the current situation and what you need to do]
Action: {"action_type": "...", ...}

## Action Space

| Action Type | Description | JSON Format Example |
|-------------|-------------|---------------------|
| `click` | Tap visible element | `{"action_type": "click", "coordinate": [x, y]}` |
| `double_tap` | Double-tap visible element | `{"action_type": "double_tap", "coordinate": [x, y]}` |
| `long_press` | Long-press visible element | `{"action_type": "long_press", "coordinate": [x, y]}` |
| `type` | Type text into field | `{"action_type": "type", "text": "your text"}` |
| `swipe` | Swipe in direction | `{"action_type": "swipe", "direction": "up/down/left/right", "coordinate": [x, y]}` |
| `drag` | Drag from point to point | `{"action_type": "drag", "start_coordinate": [x1, y1], "end_coordinate": [x2, y2]}` |
| `system_button` | Press system button | `{"action_type": "system_button", "button": "home/back"}` |
| `answer` | Answer user question | `{"action_type": "answer", "text": "answer text"}` |
| `wait` | Wait for screen update | `{"action_type": "wait"}` |
"""


def load_image_as_base64(image_path: str, max_size: tuple[int, int] | None = None) -> str:
    """Load image and encode as base64.

    Args:
        image_path: Path to the image file.
        max_size: Maximum (width, height) for resizing, None for original size.

    Returns:
        Base64 encoded image string (without data URI prefix).
    """
    img = Image.open(image_path)

    # Convert to RGB if necessary
    if img.mode != "RGB":
        img = img.convert("RGB")

    # Resize if max_size is specified
    if max_size:
        img.thumbnail(max_size, Image.Resampling.LANCZOS)

    # Encode to base64
    buffer = BytesIO()

    img.save(buffer, format="PNG")
    img_bytes = buffer.getvalue()
    return base64.b64encode(img_bytes).decode("utf-8")


def build_user_content(
    instruction: str,
    screenshot_path: str | None = None,
    history: list[dict] | None = None,
    image_format: str = "base64",
) -> list[dict]:
    """Build user message content.

    Args:
        instruction: The task instruction.
        screenshot_path: Path to the current screenshot.
        history: List of previous steps for context.
        image_format: "base64" for embedded images, "path" for file paths.

    Returns:
        List of content items (text and optional image).
    """
    content = []

    # Add screenshot if available
    if screenshot_path and os.path.exists(screenshot_path):
        if image_format == "base64":
            img_b64 = load_image_as_base64(screenshot_path)
            content.append({
                "type": "image_url",
                "image_url": {"url": f"data:image/png;base64,{img_b64}"}
            })
        else:
            content.append({
                "type": "text",
                "text": f"[Screenshot: {screenshot_path}]"
            })

    # Build instruction with history
    instruction_text = f"Task: {instruction}\n"

    if history:
        instruction_text += "\nPrevious actions:\n"
        for step in history[-5:]:  # Keep last 5 steps for context
            action = step.get("action", {})
            action_type = step.get("action_type", "unknown")
            thinking = step.get("thinking", "")

            if thinking:
                instruction_text += f"- {thinking}\n"
            if action:
                instruction_text += f"  Action: {json.dumps(action, ensure_ascii=False)}\n"

    content.append({"type": "text", "text": instruction_text})
    return content


def build_assistant_content(thinking: str, action: dict) -> list[dict]:
    """Build assistant message content.

    Args:
        thinking: The thinking process.
        action: The action taken.

    Returns:
        List with text content including thought and action.
    """
    # Format: Thought: ...\nAction: {...}
    response = thinking
    if action and isinstance(action, dict):
        response += f"\nAction: {json.dumps(action, ensure_ascii=False)}"

    return [{"type": "text", "text": response}]


def trajectory_to_sft_samples(
    trajectory_path: str,
    image_format: str = "base64",
    max_samples: int = -1,
) -> Generator[dict[str, Any], None, None]:
    """Convert trajectory.jsonl to SFT samples.

    Args:
        trajectory_path: Path to trajectory.jsonl file.
        image_format: "base64" or "path" for image handling.
        max_samples: Maximum number of samples to generate (-1 for all).

    Yields:
        SFT training samples with OpenAI-compatible message format.
    """
    # Get the directory containing screenshots
    trajectory_dir = os.path.dirname(trajectory_path)

    # Read all steps
    steps = []
    with open(trajectory_path, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if line:
                steps.append(json.loads(line))

    if not steps:
        return

    # Get instruction from first step
    instruction = steps[0].get("instruction", "")

    # Build samples for each step
    for i, step in enumerate(steps):
        if max_samples > 0 and i >= max_samples:
            break

        thinking = step.get("thinking", "")
        action = step.get("action", {})
        screenshot_path = step.get("screenshot_path", "")

        # Resolve full screenshot path
        if screenshot_path and not os.path.isabs(screenshot_path):
            # Try different path resolution strategies
            # 1. Direct join with trajectory_dir
            candidate_path = os.path.join(trajectory_dir, screenshot_path)
            if os.path.exists(candidate_path):
                full_screenshot_path = candidate_path
            else:
                # 2. screenshot_path might include the directory name already
                # e.g., "20260119_201327/step_001.png"
                filename = os.path.basename(screenshot_path)
                candidate_path2 = os.path.join(trajectory_dir, filename)
                if os.path.exists(candidate_path2):
                    full_screenshot_path = candidate_path2
                else:
                    # 3. Try parent directory
                    parent_dir = os.path.dirname(trajectory_dir)
                    candidate_path3 = os.path.join(parent_dir, screenshot_path)
                    if os.path.exists(candidate_path3):
                        full_screenshot_path = candidate_path3
                    else:
                        candidate_path4 = os.path.join(parent_dir, filename)
                        full_screenshot_path = candidate_path4 if os.path.exists(candidate_path4) else screenshot_path
        else:
            full_screenshot_path = screenshot_path

        # Skip if screenshot doesn't exist (for non-GUI steps)
        if screenshot_path and not os.path.exists(full_screenshot_path):
            continue

        # Build user content (instruction + history)
        history = steps[:i]
        user_content = build_user_content(
            instruction=instruction,
            screenshot_path=full_screenshot_path if screenshot_path else None,
            history=history,
            image_format=image_format,
        )

        # Build assistant content (thinking + action)
        assistant_content = build_assistant_content(thinking, action)

        # Create OpenAI-compatible message format
        sample = {
            "messages": [
                {
                    "role": "system",
                    "content": [{"type": "text", "text": GUI_AGENT_SYSTEM_PROMPT}]
                },
                {
                    "role": "user",
                    "content": user_content
                },
                {
                    "role": "assistant",
                    "content": assistant_content
                }
            ],
            "metadata": {
                "source": trajectory_path,
                "step_index": step.get("step_index", i),
                "action_type": step.get("action_type"),
                "success": step.get("success", True),
                "timestamp": step.get("timestamp"),
            }
        }

        yield sample


def process_single_trajectory(
    input_path: str,
    output_path: str,
    image_format: str = "base64",
    max_samples: int = -1,
) -> int:
    """Process a single trajectory.jsonl file.

    Args:
        input_path: Path to input trajectory.jsonl file.
        output_path: Path to output JSONL file.
        image_format: "base64" or "path" for image handling.
        max_samples: Maximum number of samples to generate.

    Returns:
        Number of samples written.
    """
    count = 0
    output_path = Path(output_path)
    output_path.parent.mkdir(parents=True, exist_ok=True)

    with open(output_path, "w", encoding="utf-8") as out_f:
        for sample in tqdm(
            trajectory_to_sft_samples(input_path, image_format, max_samples),
            desc=f"Processing {Path(input_path).name}",
        ):
            out_f.write(json.dumps(sample, ensure_ascii=False) + "\n")
            count += 1

    return count


def process_directory(
    input_dir: str,
    output_dir: str,
    image_format: str = "base64",
    pattern: str = "**/trajectory.jsonl",
) -> dict[str, int]:
    """Process all trajectory.jsonl files in a directory.

    Args:
        input_dir: Root directory to search for trajectory.jsonl files.
        output_dir: Directory to write output files.
        image_format: "base64" or "path" for image handling.
        pattern: Glob pattern to find trajectory files.

    Returns:
        Dictionary mapping input paths to sample counts.
    """
    input_path = Path(input_dir)
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)

    # Find all trajectory.jsonl files
    trajectory_files = list(input_path.glob(pattern))
    results = {}

    for traj_file in tqdm(trajectory_files, desc="Processing trajectories"):
        # Create output path maintaining directory structure
        rel_path = traj_file.relative_to(input_path)
        output_file = output_path / rel_path.name.replace(".jsonl", "_sft.jsonl")

        count = process_single_trajectory(
            str(traj_file),
            str(output_file),
            image_format=image_format,
        )
        results[str(traj_file)] = count

    return results


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Convert trajectory.jsonl to SFT training dataset"
    )
    parser.add_argument(
        "--input",
        "-i",
        type=str,
        required=True,
        help="Input trajectory.jsonl file or directory containing trajectory files",
    )
    parser.add_argument(
        "--output",
        "-o",
        type=str,
        required=True,
        help="Output JSONL file (for single file) or directory (for batch processing)",
    )
    parser.add_argument(
        "--image-format",
        type=str,
        choices=["base64", "path"],
        default="base64",
        help="How to include images: 'base64' (embedded) or 'path' (file paths)",
    )
    parser.add_argument(
        "--max-samples",
        type=int,
        default=-1,
        help="Maximum number of samples to generate per trajectory (-1 for all)",
    )
    parser.add_argument(
        "--config",
        "-c",
        type=str,
        help="Path to config YAML file (overrides command line args)",
    )

    args = parser.parse_args()

    # Load config if provided
    if args.config:
        with open(args.config, "r") as f:
            config = yaml.safe_load(f)
        input_path = config.get("input", args.input)
        output_path = config.get("output", args.output)
        image_format = config.get("image_format", args.image_format)
        max_samples = config.get("max_samples", args.max_samples)
    else:
        input_path = args.input
        output_path = args.output
        image_format = args.image_format
        max_samples = args.max_samples

    # Process input
    input_path_obj = Path(input_path)

    if input_path_obj.is_file():
        # Single file processing
        count = process_single_trajectory(
            input_path,
            output_path,
            image_format=image_format,
            max_samples=max_samples,
        )
        print(f"\n✓ Processed {count} samples from {input_path}")
        print(f"  Output: {output_path}")

    elif input_path_obj.is_dir():
        # Directory processing
        results = process_directory(
            input_path,
            output_path,
            image_format=image_format,
        )
        total = sum(results.values())
        print(f"\n✓ Processed {total} total samples from {len(results)} trajectories")
        for traj_file, count in results.items():
            print(f"  {Path(traj_file).name}: {count} samples")
        print(f"  Output directory: {output_path}")

    else:
        print(f"Error: Input path does not exist: {input_path}")
        return


if __name__ == "__main__":
    main()
